#%%
from astropy.io import ascii
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gs
import astropy.constants as const
import pandas as pd
import astropy.units as u
import sys
import glob
from matplotlib import cm
import scipy.stats as st
from decimal import Decimal
import os
import random # 'random' was imported but not used, keeping for now as it might be used in commented out sections or future additions
import traceback # 'traceback' was imported but not used
import warnings
from subprocess import call # 'call' from subprocess was imported but not used directly, os.system is used instead

warnings.filterwarnings("ignore")
# This line was removed to make the script more portable.
# Ensure that 'PDF_model_functions', 'radex_functions', and 'emissivity_model_functions'
# are either in the same directory as this script or are installed as packages.

plt.rcParams['text.usetex'] = True
plt.rcParams['font.serif'] = 'Computer Modern Roman'
plt.rcParams['font.family'] = 'serif'

# Local imports - ensure these files are in your project directory or accessible via PYTHONPATH.
from PDF_model_functions import get_PDFs, get_PDFs_simple, get_PDFs3 # get_PDFs_simple and get_PDFs3 are imported but not used
from radex_functions import run_multiline
from emissivity_model_functions import calc_emiss_and_SF_props

###############
# DEFINE GRID #
###############

#%%
def main(a):
    """
    Main function to process a single cloud model.

    Args:
        a (int): The index of the model to process, corresponding to the
                 output PDF file from input_measurements_grid.py.
    """
    i = a
    print(f'Processing Model: {i:.0f}')

    # GLOBAL VALUES (parameters for calculations)
    b = 0.4
    beta = np.inf
    eff0 = 1e-2 # Not used in the current visible code
    n_ref = 10**4.5
    size = 500 # Not used in this script directly, likely for PDF generation
    xhcn = 1e-8
    xco = 1.4e-4
    xhcop = 1e-8
    #avir = 1 # Commented out, not used

    # Construct the path to the input PDF file
    # Corrected f-string formatting for the filename
    f = f'output/pdf{i:.0f}.tsv'
    print(f'Reading from: {f}')

    # Read the PDF data generated by input_measurements_grid.py
    df_pdf = pd.read_csv(f, sep='\t')
    df_pdf = df_pdf.sort_values('log n_arr')

    # Extract relevant arrays from the PDF DataFrame
    log_n_arr = df_pdf['log n_arr'].values # Extracted here for plotting
    r_arr_pc = df_pdf['r_arr_pc'].values # Extracted here for plotting
    n_arr = 10**log_n_arr # Use the already extracted log_n_arr
    N_arr = 10**df_pdf['log N_arr'].values
    temp_arr = df_pdf['temp'].values
    sigma_v = df_pdf['sigma_v_3D'].values[0]
    dv = sigma_v # dv is set to sigma_v, consider if a conversion factor is needed (e.g., *2.355 for FWHM)

    # J quantum numbers for molecular transitions (e.g., CO(1-0))
    jup = 1
    jlo = 0

    # Run radiative transfer calculations using RADEX functions
    # temp_arr is cast to float to ensure compatibility with run_multiline
    df_radex = run_multiline(n_arr, N_arr, temp_arr.astype('float'),
                             X_hcn=xhcn, X_co=xco, X_hcop=xhcop,
                             dv=dv, jup=jup, jlo=jlo)

    # Calculate emissivity and star formation properties
    # corr=0.01 is passed as a correction factor for SFR calculation
    df_SF = calc_emiss_and_SF_props(df_pdf, df_radex, corr=0.01,
                                    xco=xco, xhcn=xhcn, xhcop=xhcop,
                                    lognormal=False, # Assuming composite PDF is used
                                    beta=np.inf, jup=jup, remove_out=True)

    # Extract and print CO emissivity and optical depth
    emiss_co_from_SF = df_SF['emiss10_co_K_kms_cm-2'].values # Renamed to distinguish from raw flux
    # Note: alpha_co is calculated twice here, the second one overwrites the first.
    # The constant 6.3e19 seems specific to CO(1-0) conversion.
    alpha_co = 1 / emiss_co_from_SF / 6.3e19
    tau_co_from_SF = df_SF['tau10_co_weight'].values # Renamed to distinguish from raw tau
    print(f'alpha_co = {alpha_co[0]:.2e}')
    print(f'tau_co = {tau_co_from_SF[0]:.2e}') # Using f-string for formatted output

    # Save the final DataFrame with SF properties to a TSV file
    df_SF.to_csv(f'output/model{i:.0f}.tsv', sep='\t')
    print(f'Model: {i:.0f} Success')

    # Extract data for plotting directly from df_radex
    flux_co = df_radex['FLUX_Kkm/s_co'].values
    flux_hcn = df_radex['FLUX_Kkm/s_hcn'].values
    flux_hcop = df_radex['FLUX_Kkm/s_hco+'].values
    tau_co_radex = df_radex['TAU_co'].values
    tau_hcn_radex = df_radex['TAU_hcn'].values
    tau_hcop_radex = df_radex['TAU_hco+'].values

    # Ensure output directories exist for plots
    os.makedirs('figures/models', exist_ok=True)

    # Plotting Flux and Optical Depth
    
    # Plot 1: CO Flux vs. Gas Density
    plt.figure(figsize=(8, 6))
    plt.plot(log_n_arr, flux_co, label=r'CO Flux')
    plt.xlabel(r'log $n_{H_2}$ (cm$^-3$)')
    plt.ylabel(r'Flux (K km/s)')
    plt.title(f'CO Flux vs. Gas Density (Model {i:.0f})')
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.savefig(f'figures/models/flux_co_vs_dens_model{i:.0f}.png', bbox_inches='tight')
    plt.close()

    # Plot 2: HCN Flux vs. Gas Density
    plt.figure(figsize=(8, 6))
    plt.plot(log_n_arr, flux_hcn, label=r'HCN Flux', color='orange')
    plt.xlabel(r'log $n_{H_2}$ (cm$^-3$)')
    plt.ylabel(r'Flux (K km/s)')
    plt.title(f'HCN Flux vs. Gas Density (Model {i:.0f})')
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.savefig(f'figures/models/flux_hcn_vs_dens_model{i:.0f}.png', bbox_inches='tight')
    plt.close()

    # Plot 3: HCO+ Flux vs. Gas Density
    plt.figure(figsize=(8, 6))
    plt.plot(log_n_arr, flux_hcop, label=r'HCO+ Flux', color='purple')
    plt.xlabel(r'log $n_{H_2}$ (cm$^-3$)')
    plt.ylabel(r'Flux (K km/s)')
    plt.title(f'HCO+ Flux vs. Gas Density (Model {i:.0f})')
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.savefig(f'figures/models/flux_hcop_vs_dens_model{i:.0f}.png', bbox_inches='tight')
    plt.close()

    # Plot 4: CO Optical Depth vs. Gas Density
    plt.figure(figsize=(8, 6))
    plt.plot(log_n_arr, tau_co_radex, label=r'CO Optical Depth', color='green')
    plt.xlabel(r'log $n_{H_2}$ (cm$^-3$)')
    plt.ylabel(r'Optical Depth ($\tau$)')
    plt.title(f'CO Optical Depth vs. Gas Density (Model {i:.0f})')
    plt.yscale('log') # Optical depth often spans orders of magnitude
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.savefig(f'figures/models/optical_depth_co_vs_dens_model{i:.0f}.png', bbox_inches='tight')
    plt.close()

    # Plot 5: HCN Optical Depth vs. Gas Density
    plt.figure(figsize=(8, 6))
    plt.plot(log_n_arr, tau_hcn_radex, label=r'HCN Optical Depth', color='red')
    plt.xlabel(r'log $n_{H_2}$ (cm$^-3$)')
    plt.ylabel(r'Optical Depth ($\tau$)')
    plt.title(f'HCN Optical Depth vs. Gas Density (Model {i:.0f})')
    plt.yscale('log') # Optical depth often spans orders of magnitude
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.savefig(f'figures/models/optical_depth_hcn_vs_dens_model{i:.0f}.png', bbox_inches='tight')
    plt.close()

    # Plot 6: HCO+ Optical Depth vs. Gas Density
    plt.figure(figsize=(8, 6))
    plt.plot(log_n_arr, tau_hcop_radex, label=r'HCO+ Optical Depth', color='brown')
    plt.xlabel(r'log $n_{H_2}$ (cm$^-3$)')
    plt.ylabel(r'Optical Depth ($\tau$)')
    plt.title(f'HCO+ Optical Depth vs. Gas Density (Model {i:.0f})')
    plt.yscale('log') # Optical depth often spans orders of magnitude
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.savefig(f'figures/models/optical_depth_hcop_vs_dens_model{i:.0f}.png', bbox_inches='tight')
    plt.close()

    # Plot 7: CO Flux vs. Radius
    plt.figure(figsize=(8, 6))
    plt.plot(r_arr_pc, flux_co, label=r'CO Flux')
    plt.xlabel(r'Radius (pc)')
    plt.ylabel(r'Flux (K km/s)')
    plt.title(f'CO Flux vs. Radius (Model {i:.0f})')
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.savefig(f'figures/models/flux_co_vs_radius_model{i:.0f}.png', bbox_inches='tight')
    plt.close()

    # Plot 8: HCN Flux vs. Radius
    plt.figure(figsize=(8, 6))
    plt.plot(r_arr_pc, flux_hcn, label=r'HCN Flux', color='orange')
    plt.xlabel(r'Radius (pc)')
    plt.ylabel(r'Flux (K km/s)')
    plt.title(f'HCN Flux vs. Radius (Model {i:.0f})')
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.savefig(f'figures/models/flux_hcn_vs_radius_model{i:.0f}.png', bbox_inches='tight')
    plt.close()

    # Plot 9: HCO+ Flux vs. Radius
    plt.figure(figsize=(8, 6))
    plt.plot(r_arr_pc, flux_hcop, label=r'HCO+ Flux', color='purple')
    plt.xlabel(r'Radius (pc)')
    plt.ylabel(r'Flux (K km/s)')
    plt.title(f'HCO+ Flux vs. Radius (Model {i:.0f})')
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.savefig(f'figures/models/flux_hcop_vs_radius_model{i:.0f}.png', bbox_inches='tight')
    plt.close()

    # Plot 10: CO Optical Depth vs. Radius
    plt.figure(figsize=(8, 6))
    plt.plot(r_arr_pc, tau_co_radex, label=r'CO Optical Depth', color='green')
    plt.xlabel(r'Radius (pc)')
    plt.ylabel(r'Optical Depth ($\tau$)')
    plt.title(f'CO Optical Depth vs. Radius (Model {i:.0f})')
    plt.yscale('log')
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.savefig(f'figures/models/optical_depth_co_vs_radius_model{i:.0f}.png', bbox_inches='tight')
    plt.close()

    # Plot 11: HCN Optical Depth vs. Radius
    plt.figure(figsize=(8, 6))
    plt.plot(r_arr_pc, tau_hcn_radex, label=r'HCN Optical Depth', color='red')
    plt.xlabel(r'Radius (pc)')
    plt.ylabel(r'Optical Depth ($\tau$)')
    plt.title(f'HCN Optical Depth vs. Radius (Model {i:.0f})')
    plt.yscale('log')
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.savefig(f'figures/models/optical_depth_hcn_vs_radius_model{i:.0f}.png', bbox_inches='tight')
    plt.close()

    # Plot 12: HCO+ Optical Depth vs. Radius
    plt.figure(figsize=(8, 6))
    plt.plot(r_arr_pc, tau_hcop_radex, label=r'HCO+ Optical Depth', color='brown')
    plt.xlabel(r'Radius (pc)')
    plt.ylabel(r'Optical Depth ($\tau$)')
    plt.title(f'HCO+ Optical Depth vs. Radius (Model {i:.0f})')
    plt.yscale('log')
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.savefig(f'figures/models/optical_depth_hcop_vs_radius_model{i:.0f}.png', bbox_inches='tight')
    plt.close()

    return

#%%
# Cleanup temporary RADEX files and previous model outputs
# Ensure 'output' directory exists before attempting to remove files within it
os.makedirs('output', exist_ok=True)
# These commands remove temporary RADEX input/output files and previous model outputs.
# Consider using pathlib for more robust file system operations in a production environment.
os.system('rm -f *.inp') # -f flag forces removal without prompt
os.system('rm -f radex.*')
os.system('rm -f output/model*')

# Get a list of all generated PDF files from the previous script
fils = glob.glob('output/pdf*')

# %%
# OPTIONAL: Multiprocessing block (COMMENTED OUT)
# You can uncomment this block and the 'pool.imap_unordered' line below
# if you wish to enable multiprocessing in the future.

# import multiprocessing as mp

# # Determine the number of CPU cores to use for parallel processing
# # It's common to leave a few cores free for system stability.
# nc = mp.cpu_count() - 2
# if nc < 1: # Ensure at least one process if only 1 or 2 cores are available
#     nc = 1

# # Create an array of indices corresponding to the PDF files to process
# # Assumes PDF files are named 'pdf0.tsv', 'pdf1.tsv', etc.
# # If filenames are not sequential, this needs adjustment.
# arr = np.arange(0, len(fils), 1) # Assuming 'fils' is defined elsewhere as a list or similar


# This is the sequential (non-multiprocessing) alternative:
if __name__ == '__main__':
    # Make sure 'arr' and 'main' are defined and accessible in this scope.
    # If 'arr' relies on 'fils', ensure 'fils' is defined before this block.
    # 'main' should be the function that processes each item in 'arr'.
    print("Running sequentially (no multiprocessing)...")
    arr = np.arange(0, len(fils), 1) # Redefine arr here if it was only defined in the commented block
    for item in list(arr): # Iterate directly over the array/list
        main(item) # Call your 'main' function for each item sequentially
    print("Sequential execution complete.")

# Optional:
# If you decide to use multiprocessing later, uncomment the block above
# and uncomment the following lines.
# if __name__ == '__main__':
#     # Create a multiprocessing Pool with 'nc' processes
#     # pool = mp.Pool(processes=nc)
#     # Use imap_unordered for potentially better load balancing and
#     # to get results as they become ready, without strict order.
#     # pool.imap_unordered(main, list(arr))

#     # Close the pool and wait for all child processes to complete
#     # pool.close()
#     # pool.join()

